#pragma once

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::createAsSeconds(
    BasicTime<T>::Type amount
) -> ::xrn::ecs::BasicTime<T>
{
    return ::xrn::ecs::BasicTime<T>{ amount * 1000 };
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::createAsMilliseconds(
    BasicTime<T>::Type amount
) -> ::xrn::ecs::BasicTime<T>
{
    return ::xrn::ecs::BasicTime<T>{ amount };
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::createAsMicroseconds(
    BasicTime<T>::Type amount
) -> ::xrn::ecs::BasicTime<T>
{
    return ::xrn::ecs::BasicTime<T>{ amount / 1000 };
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// *structors
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> ::xrn::ecs::BasicTime<T>::BasicTime(
    auto amount
) noexcept
    : m_time{ static_cast<BasicTime<T>::Type>(amount) }
{}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Comparison
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::operator<=>(
    const ::xrn::ecs::BasicTime<T>& rhs
) const
    -> ::std::weak_ordering = default;

///////////////////////////////////////////////////////////////////////////
template <
    typename T
>
 auto ::xrn::ecs::BasicTime<T>::operator<=>(
    const BasicTime<T>::Type& rhs
) const
    -> ::std::partial_ordering
{
    return m_time <=> rhs;
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Get
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> ::xrn::ecs::BasicTime<T>::operator BasicTime<T>::Type() noexcept
{
    return m_time;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::get() const
    -> BasicTime<T>::Type
{
    return m_time;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::getAsSeconds() const
    -> BasicTime<T>::Type
{
    return m_time / 1000;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::getAsMilliseconds() const
    -> BasicTime<T>::Type
{
    return m_time;
}


///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::getAsMicroseconds() const
    -> BasicTime<T>::Type
{
    return m_time * 1000;
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Set
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::operator=(
    const BasicTime<T>::Type& amount
) -> ::xrn::ecs::BasicTime<T>&
{
    m_time = amount;
    return *this;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> void ::xrn::ecs::BasicTime<T>::set(
    const ::xrn::ecs::BasicTime<T>& amount
)
{
    m_time = amount.m_time;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> void ::xrn::ecs::BasicTime<T>::set(
    const BasicTime<T>::Type& amount
)
{
    m_time = amount;
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Add
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::operator+=(
    const ::xrn::ecs::BasicTime<T>& rhs
) -> ::xrn::ecs::BasicTime<T>&
{
    m_time += rhs.m_time;
    return *this;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::operator+=(
    const BasicTime<T>::Type& rhs
) -> ::xrn::ecs::BasicTime<T>&
{
    m_time += rhs;
    return *this;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::operator+(
    const ::xrn::ecs::BasicTime<T>& rhs
) const
    -> ::xrn::ecs::BasicTime<T>
{
    ::xrn::ecs::BasicTime<T> newTime{ *this };
    newTime.add(rhs);
    return newTime;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::operator+(
    const BasicTime<T>::Type& rhs
) const
    -> ::xrn::ecs::BasicTime<T>
{
    ::xrn::ecs::BasicTime<T> newTime{ *this };
    newTime.add(rhs);
    return newTime;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> void ::xrn::ecs::BasicTime<T>::add(
    const ::xrn::ecs::BasicTime<T>& amount
)
{
    m_time += amount.m_time;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> void ::xrn::ecs::BasicTime<T>::add(
    const BasicTime<T>::Type& amount
)
{
    m_time += amount;
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Sub
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::operator-=(
    const ::xrn::ecs::BasicTime<T>& rhs
) -> ::xrn::ecs::BasicTime<T>&
{
    m_time -= rhs.m_time;
    return *this;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::operator-=(
    const BasicTime<T>::Type& rhs
) -> ::xrn::ecs::BasicTime<T>&
{
    m_time -= rhs;
    return *this;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::operator-(
    const ::xrn::ecs::BasicTime<T>& rhs
) const
    -> ::xrn::ecs::BasicTime<T>
{
    ::xrn::ecs::BasicTime<T> newTime{ *this };
    newTime.sub(rhs);
    return newTime;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::operator-(
    const BasicTime<T>::Type& rhs
) const
    -> ::xrn::ecs::BasicTime<T>
{
    ::xrn::ecs::BasicTime<T> newTime{ *this };
    newTime.sub(rhs);
    return newTime;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> void ::xrn::ecs::BasicTime<T>::sub(
    const ::xrn::ecs::BasicTime<T>& amount
)
{
    m_time -= amount.m_time;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> void ::xrn::ecs::BasicTime<T>::sub(
    const BasicTime<T>::Type& amount
)
{
    m_time -= amount;
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Mul
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::operator*=(
    const ::xrn::ecs::BasicTime<T>& rhs
) -> ::xrn::ecs::BasicTime<T>&
{
    m_time *= rhs.m_time;
    return *this;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::operator*=(
    const BasicTime<T>::Type& rhs
) -> ::xrn::ecs::BasicTime<T>&
{
    m_time *= rhs;
    return *this;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::operator*(
    const ::xrn::ecs::BasicTime<T>& rhs
) const
    -> ::xrn::ecs::BasicTime<T>
{
    ::xrn::ecs::BasicTime<T> newTime{ *this };
    newTime.mul(rhs);
    return newTime;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::operator*(
    const BasicTime<T>::Type& rhs
) const
    -> ::xrn::ecs::BasicTime<T>
{
    ::xrn::ecs::BasicTime<T> newTime{ *this };
    newTime.mul(rhs);
    return newTime;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> void ::xrn::ecs::BasicTime<T>::mul(
    const ::xrn::ecs::BasicTime<T>& amount
)
{
    m_time *= amount.m_time;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> void ::xrn::ecs::BasicTime<T>::mul(
    const BasicTime<T>::Type& amount
)
{
    m_time *= amount;
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Div
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::operator/=(
    const ::xrn::ecs::BasicTime<T>& rhs
) -> ::xrn::ecs::BasicTime<T>&
{
    m_time /= rhs.m_time;
    return *this;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::operator/=(
    const BasicTime<T>::Type& rhs
) -> ::xrn::ecs::BasicTime<T>&
{
    m_time /= rhs;
    return *this;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::operator/(
    const ::xrn::ecs::BasicTime<T>& rhs
) const
    -> ::xrn::ecs::BasicTime<T>
{
    ::xrn::ecs::BasicTime<T> newTime{ *this };
    newTime.div(rhs);
    return newTime;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::operator/(
    const BasicTime<T>::Type& rhs
) const
    -> ::xrn::ecs::BasicTime<T>
{
    ::xrn::ecs::BasicTime<T> newTime{ *this };
    newTime.div(rhs);
    return newTime;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> void ::xrn::ecs::BasicTime<T>::div(
    const ::xrn::ecs::BasicTime<T>& amount
)
{
    m_time /= amount.m_time;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> void ::xrn::ecs::BasicTime<T>::div(
    const BasicTime<T>::Type& amount
)
{
    m_time /= amount;
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Mod
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::operator%=(
    const ::xrn::ecs::BasicTime<T>& rhs
) -> ::xrn::ecs::BasicTime<T>&
{
    auto newValue{
        static_cast<::std::uint_fast32_t>(m_time) % static_cast<::std::uint_fast32_t>(rhs.m_time)
    };
    m_time = newValue;
    return *this;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::operator%=(
    const BasicTime<T>::Type& rhs
) -> ::xrn::ecs::BasicTime<T>&
{
    auto newValue{
        static_cast<::std::uint_fast32_t>(m_time) % static_cast<::std::uint_fast32_t>(rhs)
    };
    m_time = newValue;
    return *this;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::operator%(
    const ::xrn::ecs::BasicTime<T>& rhs
) const
    -> ::xrn::ecs::BasicTime<T>
{
    ::xrn::ecs::BasicTime<T> newTime{ *this };
    newTime.mod(rhs);
    return newTime;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::ecs::BasicTime<T>::operator%(
    const BasicTime<T>::Type& rhs
) const
    -> ::xrn::ecs::BasicTime<T>
{
    ::xrn::ecs::BasicTime<T> newTime{ *this };
    newTime.mod(rhs);
    return newTime;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> void ::xrn::ecs::BasicTime<T>::mod(
    const ::xrn::ecs::BasicTime<T>& amount
)
{
    auto newValue{
        static_cast<::std::uint_fast32_t>(m_time) % static_cast<::std::uint_fast32_t>(amount.m_time)
    };
    m_time = newValue;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> void ::xrn::ecs::BasicTime<T>::mod(
    const BasicTime<T>::Type& amount
)
{
    auto newValue{
        static_cast<::std::uint_fast32_t>(m_time) % static_cast<::std::uint_fast32_t>(amount)
    };
    m_time = newValue;
}
